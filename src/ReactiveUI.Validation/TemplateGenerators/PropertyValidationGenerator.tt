<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
// Copyright (c) 2020 .NET Foundation and Contributors. All rights reserved.
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for full license information.

//------------------------------------------------------------------------------
// <auto-generated>
//    This code was generated from a template.
//
//    Manual changes to this file may cause unexpected behavior in your application.
//    Manual changes to this file will be overwritten if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

using System;
using System.Diagnostics.CodeAnalysis;
using System.Linq.Expressions;
using System.Reactive.Disposables;
using System.Reactive.Linq;
using System.Reactive.Subjects;
using ReactiveUI.Validation.Collections;
using ReactiveUI.Validation.Comparators;
using ReactiveUI.Validation.Components;
using ReactiveUI.Validation.States;

namespace ReactiveUI.Validation.TemplateGenerators
{
<# int maxFuncLength = 6; #>
<# for(int length=2; length <= maxFuncLength; length++) { #>
<# var templParams = Enumerable.Range(1, length).Select(x => "TProperty" + x.ToString()); #>
<# string valuePropertyParams = String.Join(", ", Enumerable.Range(1, length).Select(x => String.Format("property{0}", x))); #>

    /// <inheritdoc />
    [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1649:FileHeaderFileNameDocumentationMustMatchTypeName", Justification = "Same class just generic.")]
    [SuppressMessage("StyleCop.CSharp.MaintainabilityRules", "SA1402:FileMayOnlyContainASingleType", Justification = "Same class just generic.")]
    public sealed class BasePropertyValidation<TViewModel, <#= String.Join(", ",templParams) #>>
        : BasePropertyValidation<TViewModel>
    {
        /// <summary>
        /// Represents the current value.
        /// </summary>
        private readonly Subject<(<#= String.Join(", ",templParams) #>)> _valueSubject = new Subject<(<#= String.Join(", ",templParams) #>)>();

        /// <summary>
        /// The validation message factory.
        /// </summary>
        private readonly Func<(<#= String.Join(", ",templParams) #>), bool, ValidationText> _message;

        /// <summary>
        /// The connected observable to see updates in properties being validated.
        /// </summary>
        private readonly IConnectableObservable<(<#= String.Join(", ",templParams) #>)> _valueConnectedObservable;

        /// <summary>
        /// Function to determine if valid or not.
        /// </summary>
        private readonly Func<(<#= String.Join(", ",templParams) #>), bool> _isValidFunc;

        private CompositeDisposable _disposables = new CompositeDisposable();

        /// <summary>
        /// Are we connected.
        /// </summary>
        private bool _connected;

        [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented", Justification = "Generated dynamically with template.")]
        public BasePropertyValidation(
            TViewModel viewModel,
    <# for(int property=1;property <= length;++property) { #>
        Expression<Func<TViewModel, TProperty<#=property#>>> property<#=property #>,<#Write("\r\n");#>
    <# } #>
        Func<(<#=String.Join(", ",templParams)#>), bool> isValidFunc,<#Write("\r\n");#>
            Func<(<#=String.Join(", ",templParams)#>), string> message)
            : this(viewModel, <#=String.Join(", ",valuePropertyParams)#>, isValidFunc, (p, v) => v ? ValidationText.Empty : ValidationText.Create(message(p)))
        {
        }

        [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented", Justification = "Generated dynamically with template.")]
        public BasePropertyValidation(
            TViewModel viewModel,
    <# for(int property=1;property <= length;++property) { #>
        Expression<Func<TViewModel, TProperty<#=property#>>> property<#=property #>,<#Write("\r\n");#>
    <# } #>
        Func<(<#=String.Join(", ",templParams) #>), bool> isValidFunc,
            Func<(<#=String.Join(", ",templParams)#>), bool, string> messageFunc)
            : this(viewModel, <#=String.Join(", ",valuePropertyParams)#>, isValidFunc, (p, v) => ValidationText.Create(messageFunc(p, v)))
        {
        }

        [SuppressMessage("StyleCop.CSharp.DocumentationRules", "SA1600:ElementsMustBeDocumented", Justification = "Generated dynamically with template.")]
        public BasePropertyValidation(
            TViewModel viewModel,
    <# for(int property=1;property <= length;++property) { #>
        Expression<Func<TViewModel, TProperty<#=property#>>> property<#=property #>,<#Write("\r\n");#>
    <# } #>
        Func<(<#= String.Join(", ",templParams) #>), bool> isValidFunc,
            Func<(<#= String.Join(", ",templParams) #>), bool, ValidationText> message)
        {
<# for(int property=1;property <= length;++property) { #>
            if (property<#=property#> is null)
            {
                throw new ArgumentNullException(nameof(property<#=property#>));
            }<#Write("\r\n");#><#Write("\r\n");#>
<# } #>
            _message = message ?? throw new ArgumentNullException(nameof(message));
            _isValidFunc = isValidFunc ?? throw new ArgumentNullException(nameof(isValidFunc));<#Write("\r\n");#><#Write("\r\n");#>
            // Add the properties used to our list
            <# for(int property=1;property<=length;property++) { #>
AddProperty(property<#=property#>);
            <#}#>
_disposables.Add(_valueSubject.Subscribe(v => LastValue = v));

            // Setup a connected observable to see when values change and cast that to our value subject
            _valueConnectedObservable = viewModel.WhenAnyValue(<#=valuePropertyParams#>)
                .DistinctUntilChanged()
                .Multicast(_valueSubject);
        }

        /// <summary>
        /// Gets or sets the last calculated value of the properties.
        /// </summary>
        private (<#= String.Join(", ",templParams) #>) LastValue { get; set; }

        /// <inheritdoc/>
        protected override IObservable<IValidationState> GetValidationChangeObservable()
        {
            Activate();

            return _valueSubject.Select(value =>
            {
                var isValid = _isValidFunc(value);
                return new ValidationState(isValid, GetMessage(value, isValid), this);
            }).DistinctUntilChanged(new ValidationStateComparer());
        }

        /// <inheritdoc/>
        protected override void Dispose(bool disposing)
        {
            if (disposing)
            {
                _disposables?.Dispose();
            }
        }

        /// <summary>
        /// Gets the validation message.
        /// </summary>
        /// <param name="params">ViewModel properties.</param>
        /// <param name="isValid">Whether the property is valid or not.</param>
        /// <returns>Returns the <see cref="ValidationText"/> object.</returns>
        private ValidationText GetMessage((<#=String.Join(", ",templParams)#>) @params, bool isValid)
        {
            return _message(@params, isValid);
        }

        /// <summary>
        /// Activate the connection to ensure we start seeing validations.
        /// </summary>
        private void Activate()
        {
            if (!_connected)
            {
                _connected = true;
                _disposables.Add(_valueConnectedObservable.Connect());
            }
        }
    }
<# } #>
}
